/***** BEGIN LICENSE BLOCK *****
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this file,
# You can obtain one at http://mozilla.org/MPL/2.0/.
#
# The Initial Developer of the Original Code is the Mozilla Foundation.
# Portions created by the Initial Developer are Copyright (C) 2012
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mike Trinkala (trink@mozilla.com)
#
# ***** END LICENSE BLOCK *****/
package lua

/*
#cgo CFLAGS: -std=gnu99 -I @LUA_INCLUDE_PATH@
#cgo LDFLAGS: -L@LUA_LIB_PATH@ -lluasandbox -llua -llpeg -lcjson -lm
#include <stdlib.h>
#include <lua_sandbox.h>
#include "lua_sandbox_interface.h"
*/
import "C"

import (
	"fmt"
	"github.com/mozilla-services/heka/message"
	"github.com/mozilla-services/heka/pipeline"
	"github.com/mozilla-services/heka/sandbox"
	"log"
	"strings"
	"unsafe"
)

var (
	LMW_ERR_NO_SANDBOX_PACK    = int(C.LMW_ERR_NO_SANDBOX_PACK)
	LMW_ERR_WRONG_TYPE         = int(C.LMW_ERR_WRONG_TYPE)
	LMW_ERR_NEWFIELD_FAILED    = int(C.LMW_ERR_NEWFIELD_FAILED)
	LMW_ERR_BAD_FIELD_INDEX    = int(C.LMW_ERR_BAD_FIELD_INDEX)
	LMW_ERR_BAD_ARRAY_INDEX    = int(C.LMW_ERR_BAD_ARRAY_INDEX)
	LMW_ERR_INVALID_FIELD_NAME = int(C.LMW_ERR_INVALID_FIELD_NAME)
)

func lookup_field(msg *message.Message, fn string, fi, ai int) (int,
	unsafe.Pointer, int) {

	var field *message.Field
	if fi != 0 {
		fields := msg.FindAllFields(fn)
		if fi >= len(fields) {
			return 0, unsafe.Pointer(nil), 0
		}
		field = fields[fi]
	} else {
		if field = msg.FindFirstField(fn); field == nil {
			return 0, unsafe.Pointer(nil), 0
		}
	}
	fieldType := int(field.GetValueType())
	switch field.GetValueType() {
	case message.Field_STRING:
		if ai >= len(field.ValueString) {
			return fieldType, unsafe.Pointer(nil), 0
		}
		value := field.ValueString[ai]
		cs := C.CString(value) // freed by the caller
		return fieldType, unsafe.Pointer(cs), len(value)
	case message.Field_BYTES:
		if ai >= len(field.ValueBytes) {
			return fieldType, unsafe.Pointer(nil), 0
		}
		value := field.ValueBytes[ai]
		return fieldType, unsafe.Pointer(&field.ValueBytes[ai][0]), len(value)
	case message.Field_INTEGER:
		if ai >= len(field.ValueInteger) {
			return fieldType, unsafe.Pointer(nil), 0
		}
		return fieldType, unsafe.Pointer(&field.ValueInteger[ai]), 0
	case message.Field_DOUBLE:
		if ai >= len(field.ValueDouble) {
			return fieldType, unsafe.Pointer(nil), 0
		}
		return fieldType, unsafe.Pointer(&field.ValueDouble[ai]), 0
	case message.Field_BOOL:
		if ai >= len(field.ValueBool) {
			return fieldType, unsafe.Pointer(nil), 0
		}
		return fieldType, unsafe.Pointer(&field.ValueBool[ai]), 0
	}
	return 0, unsafe.Pointer(nil), 0
}

// Enforces field and array index limits.
func write_to_field(msg *message.Message, fn string, value interface{}, rep *C.char,
	fi, ai int) int {

	var field *message.Field
	var err error
	fields := msg.FindAllFields(fn)

	// We're only allowed to modify existing fields or extend the field length
	// by one.
	if fi > len(fields) {
		return LMW_ERR_BAD_FIELD_INDEX
	}

	if fi == len(fields) {
		// `fi == len(fields)` ==> we're creating a new field. Only array index
		// of zero is allowed.
		if ai != 0 {
			return LMW_ERR_BAD_ARRAY_INDEX
		}
		vC, ok := value.(*C.char)
		if ok {
			value = C.GoString(vC)
		}
		if field, err = message.NewField(fn, value, C.GoString(rep)); err != nil {
			fmt.Println("NewField err: ", err)
			return LMW_ERR_NEWFIELD_FAILED
		}
		msg.AddField(field)
		return 0
	}

	// Getting this far means the field we've asked for already exists, check
	// that the type matches, and ensure that we're overwriting a previous
	// array value or are extending the array length by one before writing.
	field = fields[fi]
	switch field.GetValueType() {
	case message.Field_STRING:
		vC, ok := value.(*C.char)
		if !ok {
			return LMW_ERR_WRONG_TYPE
		}
		v := C.GoString(vC)
		if ai > len(field.ValueString) {
			return LMW_ERR_BAD_ARRAY_INDEX
		}
		if ai == len(field.ValueString) {
			field.ValueString = append(field.ValueString, v)
		} else {
			field.ValueString[ai] = v
		}
	case message.Field_BYTES:
		v, ok := value.([]byte)
		if !ok {
			return LMW_ERR_WRONG_TYPE
		}
		if ai > len(field.ValueBytes) {
			return LMW_ERR_BAD_ARRAY_INDEX
		}
		if ai == len(field.ValueBytes) {
			field.ValueBytes = append(field.ValueBytes, v)
		} else {
			field.ValueBytes[ai] = v
		}
	case message.Field_INTEGER:
		v, ok := value.(int32)
		if !ok {
			return LMW_ERR_WRONG_TYPE
		}
		if ai > len(field.ValueInteger) {
			return LMW_ERR_BAD_ARRAY_INDEX
		}
		if ai == len(field.ValueInteger) {
			field.ValueInteger = append(field.ValueInteger, int64(v))
		} else {
			field.ValueInteger[ai] = int64(v)
		}
	case message.Field_DOUBLE:
		v, ok := value.(float64)
		if !ok {
			return LMW_ERR_WRONG_TYPE
		}
		if ai > len(field.ValueDouble) {
			return LMW_ERR_BAD_ARRAY_INDEX
		}
		if ai == len(field.ValueDouble) {
			field.ValueDouble = append(field.ValueDouble, v)
		} else {
			field.ValueDouble[ai] = v
		}
	case message.Field_BOOL:
		v, ok := value.(bool)
		if !ok {
			return LMW_ERR_WRONG_TYPE
		}
		if ai > len(field.ValueBool) {
			return LMW_ERR_BAD_ARRAY_INDEX
		}
		if ai == len(field.ValueBool) {
			field.ValueBool = append(field.ValueBool, v)
		} else {
			field.ValueBool[ai] = v
		}
	}
	repStr := C.GoString(rep)
	field.Representation = &repStr
	return 0
}

//export go_lua_read_message
func go_lua_read_message(ptr unsafe.Pointer, c *C.char, fi, ai int) (int, unsafe.Pointer,
	int) {
	var lsb *LuaSandbox = (*LuaSandbox)(ptr)
	if lsb.pack != nil {
		fieldName := C.GoString(c)
		switch fieldName {
		case "Type":
			value := lsb.pack.Message.GetType()
			cs := C.CString(value) // freed by the caller
			return int(message.Field_STRING), unsafe.Pointer(cs),
				len(value)
		case "Logger":
			value := lsb.pack.Message.GetLogger()
			cs := C.CString(value) // freed by the caller
			return int(message.Field_STRING), unsafe.Pointer(cs),
				len(value)
		case "Payload":
			value := lsb.pack.Message.GetPayload()
			cs := C.CString(value) // freed by the caller
			return int(message.Field_STRING), unsafe.Pointer(cs),
				len(value)
		case "EnvVersion":
			value := lsb.pack.Message.GetEnvVersion()
			cs := C.CString(value) // freed by the caller
			return int(message.Field_STRING), unsafe.Pointer(cs),
				len(value)
		case "Hostname":
			value := lsb.pack.Message.GetHostname()
			cs := C.CString(value) // freed by the caller
			return int(message.Field_STRING), unsafe.Pointer(cs),
				len(value)
		case "Uuid":
			value := lsb.pack.Message.GetUuidString()
			cs := C.CString(value) // freed by the caller
			return int(message.Field_STRING), unsafe.Pointer(cs),
				len(value)
		case "Timestamp":
			return int(message.Field_INTEGER),
				unsafe.Pointer(lsb.pack.Message.Timestamp), 0
		case "Severity":
			return int(message.Field_INTEGER),
				unsafe.Pointer(lsb.pack.Message.Severity), 0
		case "Pid":
			return int(message.Field_INTEGER),
				unsafe.Pointer(lsb.pack.Message.Pid), 0
		case "raw":
			return int(message.Field_BYTES),
				unsafe.Pointer(&lsb.pack.MsgBytes[0]), len(lsb.pack.MsgBytes)
		default:
			l := len(fieldName)
			if l > 0 && fieldName[l-1] == ']' {
				if strings.HasPrefix(fieldName, "Fields[") {
					t, p, l := lookup_field(lsb.pack.Message, fieldName[7:l-1], fi, ai)
					return t, p, l
				}
			}
		}
	}
	return 0, unsafe.Pointer(nil), 0
}

//export go_lua_write_message_string
func go_lua_write_message_string(ptr unsafe.Pointer, c, v, rep *C.char,
	fi, ai int) int {

	var lsb *LuaSandbox = (*LuaSandbox)(ptr)
	if lsb.pack == nil {
		return LMW_ERR_NO_SANDBOX_PACK
	}

	fieldName := C.GoString(c)
	switch fieldName {
	case "Type":
		lsb.pack.Message.SetType(C.GoString(v))
		return 0
	case "Logger":
		lsb.pack.Message.SetLogger(C.GoString(v))
		return 0
	case "Payload":
		lsb.pack.Message.SetPayload(C.GoString(v))
		return 0
	case "EnvVersion":
		lsb.pack.Message.SetEnvVersion(C.GoString(v))
		return 0
	case "Hostname":
		lsb.pack.Message.SetHostname(C.GoString(v))
		return 0
	case "Uuid":
		value := C.GoString(v)
		lsb.pack.Message.SetUuid([]byte(value))
		return 0
	case "Timestamp", "Severity", "Pid":
		return LMW_ERR_WRONG_TYPE
	default:
		l := len(fieldName)
		if l > 0 && fieldName[l-1] == ']' {
			if strings.HasPrefix(fieldName, "Fields[") {
				return write_to_field(lsb.pack.Message, fieldName[7:l-1],
					v, rep, fi, ai)
			}
		}
		return LMW_ERR_INVALID_FIELD_NAME
	}
}

//export go_lua_write_message_int
func go_lua_write_message_int(ptr unsafe.Pointer, c *C.char, v C.int, rep *C.char,
	fi, ai int) int {

	var lsb *LuaSandbox = (*LuaSandbox)(ptr)
	if lsb.pack == nil {
		return LMW_ERR_NO_SANDBOX_PACK
	}

	fieldName := C.GoString(c)
	switch fieldName {
	case "Severity":
		lsb.pack.Message.SetSeverity(int32(v))
		return 0
	case "Pid":
		lsb.pack.Message.SetPid(int32(v))
		return 0
	case "Type", "Logger", "Payload", "EnvVersion", "Hostname", "Uuid", "Timestamp":
		return LMW_ERR_WRONG_TYPE
	default:
		l := len(fieldName)
		if l > 0 && fieldName[l-1] == ']' {
			if strings.HasPrefix(fieldName, "Fields[") {
				return write_to_field(lsb.pack.Message, fieldName[7:l-1],
					int32(v), rep, fi, ai)
			}
		}
		return LMW_ERR_INVALID_FIELD_NAME
	}
}

//export go_lua_write_message_double
func go_lua_write_message_double(ptr unsafe.Pointer, c *C.char, v C.double, rep *C.char,
	fi, ai int) int {

	fieldName := C.GoString(c)
	var lsb *LuaSandbox = (*LuaSandbox)(ptr)
	if lsb.pack == nil {
		return LMW_ERR_NO_SANDBOX_PACK
	}

	switch fieldName {
	case "Timestamp":
		value := float64(v)
		lsb.pack.Message.SetTimestamp(int64(value))
		return 0
	default:
		l := len(fieldName)
		if l > 0 && fieldName[l-1] == ']' {
			if strings.HasPrefix(fieldName, "Fields[") {
				value := float64(v)
				return write_to_field(lsb.pack.Message, fieldName[7:l-1],
					value, rep, fi, ai)
			}
		}
	}
	return 1
}

//export go_lua_write_message_bool
func go_lua_write_message_bool(ptr unsafe.Pointer, c *C.char, v bool, rep *C.char,
	fi, ai int) int {

	fieldName := C.GoString(c)
	var lsb *LuaSandbox = (*LuaSandbox)(ptr)
	if lsb.pack == nil {
		return LMW_ERR_NO_SANDBOX_PACK
	}

	l := len(fieldName)
	if l > 0 && fieldName[l-1] == ']' {
		if strings.HasPrefix(fieldName, "Fields[") {
			return write_to_field(lsb.pack.Message, fieldName[7:l-1],
				v, rep, fi, ai)
		}
	}
	return 1
}

//export go_lua_read_config
func go_lua_read_config(ptr unsafe.Pointer, c *C.char) (int, unsafe.Pointer, int) {
	name := C.GoString(c)
	var lsb *LuaSandbox = (*LuaSandbox)(ptr)
	if lsb.config == nil {
		return 0, unsafe.Pointer(nil), 0
	}

	v := lsb.config[name]
	switch v.(type) {
	case string:
		s := v.(string)
		cs := C.CString(s) // freed by the caller
		return int(message.Field_STRING), unsafe.Pointer(cs), len(s)
	case bool:
		b := v.(bool)
		return int(message.Field_BOOL), unsafe.Pointer(&b), 0
	case int64:
		d := float64(v.(int64))
		return int(message.Field_DOUBLE), unsafe.Pointer(&d), 0
	case float64:
		d := v.(float64)
		return int(message.Field_DOUBLE), unsafe.Pointer(&d), 0
	}
	return 0, unsafe.Pointer(nil), 0
}

//export go_lua_inject_message
func go_lua_inject_message(ptr unsafe.Pointer, payload *C.char,
	payload_len C.int, payload_type, payload_name *C.char) int {
	var lsb *LuaSandbox = (*LuaSandbox)(ptr)
	return lsb.injectMessage(C.GoStringN(payload, payload_len),
		C.GoString(payload_type), C.GoString(payload_name))
}

type LuaSandbox struct {
	lsb           *C.lua_sandbox
	pack          *pipeline.PipelinePack
	output        func(s string)
	injectMessage func(payload, payload_type, payload_name string) int
	config        map[string]interface{}
}

func CreateLuaSandbox(conf *sandbox.SandboxConfig) (sandbox.Sandbox,
	error) {
	lsb := new(LuaSandbox)
	cs := C.CString(conf.ScriptFilename)
	defer C.free(unsafe.Pointer(cs))
	md := C.CString(conf.ModuleDirectory)
	defer C.free(unsafe.Pointer(md))
	lsb.lsb = C.lsb_create(unsafe.Pointer(lsb),
		cs,
		md,
		C.uint(conf.MemoryLimit),
		C.uint(conf.InstructionLimit),
		C.uint(conf.OutputLimit))
	if lsb.lsb == nil {
		return nil, fmt.Errorf("Sandbox creation failed")
	}
	lsb.output = func(s string) { log.Println(s) }
	lsb.injectMessage = func(p, pt, pn string) int {
		log.Printf("payload_type: %s\npayload_name: %s\npayload: %s\n", pt, pn, p)
		return 0
	}
	lsb.config = conf.Config
	return lsb, nil
}

func (this *LuaSandbox) Init(dataFile string) error {
	cs := C.CString(dataFile)
	defer C.free(unsafe.Pointer(cs))
	r := int(C.sandbox_init(this.lsb, cs))
	if r != 0 {
		return fmt.Errorf("Init() %s", this.LastError())
	}
	return nil
}

func (this *LuaSandbox) Destroy(dataFile string) error {
	cs := C.CString(dataFile)
	defer C.free(unsafe.Pointer(cs))
	c := C.lsb_destroy(this.lsb, cs)
	if c != nil {
		err := C.GoString(c)
		C.free(unsafe.Pointer(c))
		return fmt.Errorf("Destroy() %s", err)
	}
	return nil
}

func (this *LuaSandbox) Status() int {
	return int(C.lsb_get_state(this.lsb))
}

func (this *LuaSandbox) LastError() string {
	return C.GoString(C.lsb_get_error(this.lsb))
}

func (this *LuaSandbox) Usage(utype, ustat int) uint {
	return uint(C.lsb_usage(this.lsb, C.lsb_usage_type(utype),
		C.lsb_usage_stat(ustat)))
}

func (this *LuaSandbox) ProcessMessage(pack *pipeline.PipelinePack) int {
	this.pack = pack
	r := int(C.process_message(this.lsb))
	this.pack = nil
	return r
}

func (this *LuaSandbox) TimerEvent(ns int64) int {
	return int(C.timer_event(this.lsb, C.longlong(ns)))
}

func (this *LuaSandbox) InjectMessage(f func(payload, payload_type,
	payload_name string) int) {
	this.injectMessage = f
}
